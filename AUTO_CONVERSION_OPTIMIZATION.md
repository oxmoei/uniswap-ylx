# 自动兑换即时响应优化

## 问题描述

用户反馈自动兑换未能立即出结果，存在明显的延迟。主要原因是：

1. **异步查询延迟**：价格获取依赖 REST API 查询，需要等待网络响应
2. **缺少缓存机制**：每次都需要重新获取价格，无法利用已缓存的数据
3. **计算逻辑等待**：需要等待所有价格都加载完成才开始计算

## 优化方案

### 1. 添加查询缓存配置

在 `packages/uniswap/src/data/rest/getPortfolio.ts` 中：

```typescript
return queryOptions({
  queryKey: [...],
  staleTime: 30 * 1000, // 30秒内数据视为新鲜，避免不必要的重新获取
  gcTime: 5 * 60 * 1000, // 5分钟内保持缓存，提供即时响应
  // ...
})
```

**效果**：
- 30秒内的重复查询直接使用缓存，无需等待网络请求
- 5分钟内的缓存数据可用于即时响应，即使后台正在更新

### 2. 优化价格计算逻辑

在 `packages/uniswap/src/features/transactions/swap/stores/swapFormStore/hooks/useDerivedSwapInfo.ts` 中：

**改进前**：
- 必须等待 `inputTokenPriceUSD` 和 `outputTokenPriceUSD` 都不为 `undefined` 才开始计算
- 如果价格还在加载中，不会显示任何结果

**改进后**：
- 支持即时计算，即使价格还在加载中也可以使用缓存的价格
- 添加稳定币价格的即时推断（稳定币价格 = 1 USD）
- 优化了计算逻辑，减少不必要的等待

### 3. 利用 React Query 的缓存机制

React Query 的 `placeholderData: (prev) => prev` 配置确保：
- 使用之前的缓存数据作为占位符
- 即使查询还在进行中，也能立即显示结果
- 后台更新完成后自动刷新

## 优化效果

1. **即时响应**：如果价格已缓存，计算结果立即显示
2. **减少网络请求**：30秒内的重复查询使用缓存
3. **更好的用户体验**：即使价格还在加载，也能使用缓存数据计算

## 使用场景

### 场景 1：首次输入（无缓存）
- 用户输入金额后，触发价格查询
- 查询完成后，立即显示计算结果
- 后续输入使用缓存，即时响应

### 场景 2：重复输入（有缓存）
- 用户修改输入金额
- 直接使用缓存的价格数据
- **立即显示计算结果**（无需等待网络请求）

### 场景 3：稳定币兑换
- 如果输入或输出是稳定币，立即使用 1 USD 的价格
- 无需等待 API 响应

## 技术细节

### 缓存策略

- **staleTime: 30秒**：数据在30秒内视为新鲜，不会重新获取
- **gcTime: 5分钟**：缓存数据保留5分钟，可用于即时响应
- **placeholderData**：使用之前的缓存数据作为占位符

### 价格获取优先级

1. **REST API 价格**（优先使用缓存）
2. **稳定币价格**（即时推断，1 USD）
3. **交易路由价格**（已禁用，作为备用）

### 计算逻辑

```typescript
// 支持即时计算，即使价格还在加载中
if (effectiveInputPrice !== undefined && effectiveOutputPrice !== undefined) {
  // 立即计算并显示结果
  const outputAmount = (inputAmount * inputPrice) / outputPrice
}
```

## 注意事项

1. **首次查询**：如果用户第一次输入，仍需要等待 API 响应（通常 < 1秒）
2. **缓存失效**：30秒后数据视为过期，会重新获取（后台更新）
3. **网络延迟**：如果网络较慢，首次查询可能需要更长时间

## 后续优化建议

1. **预加载价格**：在用户选择代币时预加载价格数据
2. **本地存储**：将常用代币价格存储到 localStorage
3. **价格估算**：使用历史价格或链上数据作为估算值


